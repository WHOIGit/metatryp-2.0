"""name: query_by_sequence.pyusage: query_by_sequence.py [--max-distance=0] sequence_filecommissioned by : Dr. Makoto Saito, 2013-03authorship: adorsk, 2013-05, updated by David Gaylord 2016-12description: This script queries a peptides database for the given set ofpeptide sequences.Outputs: a CSV document to stdout whose rows contains:    query_sequence | taxon_id | levenshtein_distance | match_sequence""""""Imports and setup."""from proteomics import dbimport argparseimport logging"""Process arguments."""argparser = argparse.ArgumentParser(description=(    'Query database for peptide sequences'))argparser.add_argument('--max-distance', type=int, nargs='?', default=0,                       help=(                           'List of FASTA files containing protein sequences.'                       ))argparser.add_argument('--sequence-file', help=(   'File containing one amino acid sequence per line.'))argparser.add_argument('--sequence', help='Amino acid sequence')argparser.add_argument('--type', help='Type of search to perform')"""Main method."""def main():    args = argparser.parse_args()    logger = logging.getLogger('query_by_sequence')    logger.addHandler(logging.StreamHandler())    logger.setLevel(logging.INFO)    # Read in sequences to query.    sequences = []    max_dist = args.max_distance    if args.sequence_file:        with open(args.sequence_file, 'rb') as f:            sequences = [line.strip() for line in f.readlines()]    elif args.sequence:        sequences = [args.sequence]    # Read in whether to query just genomes ('g'), just metagenomes ('g') or both ('b').    # Genomes is the default search    type = 'g'    if args.type:        type = args.type    if not sequences:        argparser.error("Provide a query sequence via the '--sequence' option, "                        "or a set of sequences via the --sequence-file option")    # Print headers.    headers = ['query', 'taxon', 'lev_distance', 'match']    print(','.join(headers))    # Execute query for each sequence and print results.    cur = db.get_psycopg2_cursor()    for seq in sequences:        if type == 'g' or type == 'all':            hierachy = []            results=[]            taxon_lca=''            print('GENOMIC RESULTS')            print('LCA,search sequence,id,name')            if max_dist == 0:                cur.execute("select id, genome_name, hierachy from genomic_query_taxon_by_peptide_sequence_new(%s)", (seq,))            else:                #change this query when we add fuzzy matching                cur.execute("select id, genome_name, hierachy from genomic_query_taxon_by_peptide_sequence_new(%s)", (seq,))            for row in cur.fetchall():                hierachy.append(row[0])                results.append(','.join([seq, str(row[0]), row[1]]))               #print(','.join([str(s) for s in [seq] + list(row)]))            cur.execute("select * from genomic_lca(%s);", [hierachy])            if hierachy:                lca = cur.fetchone()                if lca is not None:                 taxonHierachy = lca[0].split(".")                 # iterate through taxon hierachy backwards until we find the first record that is not "unclassified"                 for l in taxonHierachy[::-1]:                     if l.lower() != "unclassified":                         taxon_lca = l                         break                else:                 taxon_lca = "Unknown"            for r in results:                print(','.join([taxon_lca, r]))        if type == 'sa' or type == 'all':            hierachy=[]            results=[]            print('\n');            print('SPECIALIZED ASSEMBLY RESULTS')            print('LCA,search sequence,genome name, sequence id, NCBI ID')            cur.execute(                "select specialized_assembly_name, specialized_assembly_sequence, ncbi_id from specialized_assembly_taxon_query_by_peptide_sequence(%s)",                (seq,))            for row in cur.fetchall():                ncbi_id = row[2]                hierachy.append(ncbi_id)                results.append(','.join([str(s) for s in [seq] + list(row)]))            if hierachy:                assembly_lca = ""                # get the least common ancester for hierachy list                cur.execute("select * from specialized_assembly_lca(%s);", [hierachy])                lca = cur.fetchone()                if lca is not None:                    # print lca[0]                    taxonHierachy = lca[0].split(".")                    # iterate through taxon hierachy backwards until we find the first record that is not "unclassified"                    for l in taxonHierachy[::-1]:                        if l.lower() != "unclassified":                            assembly_lca = l                            break                else:                    assembly_lca = "Unknown"            for r in results:                print(','.join([assembly_lca, r]))        if type == 'm' or type == 'all':            hierachy = []            results = []            print('\n');            print('METAGENOMNIC RESULTS')            print('LCA, search sequence, metagenome name, NCBI ID')            cur.execute("select metagenome_name, contig_tax_id, orf_tax_id from metagenomic_query_by_peptide_sequence(%s)", (seq,))            for row in cur.fetchall():                name = row[0]                contig_tax_id=row[1]                orf_tax_id=row[2]                if contig_tax_id:                    prefered_tax_id = contig_tax_id                elif orf_tax_id:                    prefered_tax_id = orf_tax_id                hierachy.append(prefered_tax_id)                results.append(','.join([seq,name,str(prefered_tax_id)]))                # get the least common ancester for hierachy list            if hierachy:                cur.execute("select * from metagenomic_lca2(%s);", [hierachy])                lca = cur.fetchone()                metagenome_lca = ""                if lca is not None:                    taxonHierachy = lca[0].split(".")                    # iterate through taxon hierachy backwards until we find the first record that is not "unclassified"                    for l in taxonHierachy[::-1]:                        # print l                        if l.lower() != "unclassified":                            metagenome_lca = l                            break                else:                    metagenome_lca = "Unknown"            for r in results:                print(','.join([metagenome_lca, r]))    db.psycopg2_connection.commit()if __name__ == '__main__':    main()